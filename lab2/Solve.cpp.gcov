        -:    0:Source:src/Solve.cpp
        -:    1:#include "../include/Solve.h"
        -:    2:
        2:    3:Solver::Solver() : initialized(false), bestSolution(Graph(), 0) {}
        -:    4:
        2:    5:bool Solver::initialize(const string &filename) {
        2:    6:    if (!graph.createFromFile(filename)) {
        -:    7:        return false;
        -:    8:    }
        -:    9:
        4:   10:    dangerHeuristic = std::make_unique<DangerHeuristic>(graph);
        4:   11:    bounds = std::make_unique<Bounds>(graph);
        2:   12:    bnb = std::make_unique<BranchAndBound>(graph, *bounds, *dangerHeuristic);
        -:   13:    // Reinicializar bestSolution con el grafo actual
        2:   14:    bestSolution = ColoringState(graph, graph.getVertexCount());
        2:   15:    initialized = true;
        2:   16:    return true;
        -:   17:}
        -:   18:
        2:   19:void Solver::solve() {
        2:   20:    if (!initialized) {
    #####:   21:        throw std::runtime_error("Solver not initialized");
        -:   22:    }
        -:   23:
        2:   24:    auto start = std::chrono::steady_clock::now();
        -:   25:
        -:   26:    try {
        2:   27:        bnb->solve(bestSolution);
    =====:   28:    } catch (const std::exception &e) {
    =====:   29:        std::cerr << "Error during solving: " << e.what() << std::endl;
    =====:   30:        throw;
    =====:   31:    }
        -:   32:
        2:   33:    auto end = std::chrono::steady_clock::now();
        -:   34:    executionTime =
        2:   35:        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        2:   36:}
        -:   37:
        2:   38:void Solver::printSolution() const {
        2:   39:    if (!initialized) {
        -:   40:        std::cout << "No solution available" << std::endl;
    #####:   41:        return;
        -:   42:    }
        -:   43:
        -:   44:    // Imprimir asignación de colores
      288:   45:    for (int v = 0; v < graph.getVertexCount(); v++) {
      572:   46:        std::cout << v << " " << bestSolution.getColor(v) << std::endl;
        -:   47:    }
        -:   48:
        2:   49:    std::cout << "Total colores: " << bestSolution.getNumColors() << std::endl;
        -:   50:    std::cout << "Tiempo: " << executionTime.count() << " [ms]" << std::endl;
        -:   51:
        2:   52:    if (!bestSolution.isLegal()) {
        -:   53:        std::cout << "WARNING: La solución tiene "
    #####:   54:                  << bestSolution.getNumConflicts() << " conflictos!"
        -:   55:                  << std::endl;
        -:   56:    }
        -:   57:}
